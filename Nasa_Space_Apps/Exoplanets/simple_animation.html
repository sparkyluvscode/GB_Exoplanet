<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exoplanet Animation</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
        #animation-container {
            width: 100%;
            height: 100vh;
            position: relative;
        }
        #controls {
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 100;
            background: linear-gradient(135deg, rgba(0,0,0,0.8), rgba(20,20,20,0.9));
            padding: 15px;
            border-radius: 12px;
            color: white;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
        }
        #info-panel {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 100;
            background: linear-gradient(135deg, rgba(0,0,0,0.8), rgba(20,20,20,0.9));
            padding: 15px;
            border-radius: 12px;
            color: white;
            font-size: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
            min-width: 200px;
        }
        .control-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            padding: 10px 16px;
            margin: 4px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            min-width: 80px;
        }
        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        .control-button.playing {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
        }
        .control-button.reset {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
        }
    </style>
</head>
<body>
    <div id="animation-container">
        <div id="controls">
            <button id="playButton" class="control-button" onclick="togglePlayPause()">‚ñ∂Ô∏è Play</button>
            <button id="resetButton" class="control-button reset" onclick="resetAnimation()">üîÑ Reset</button>
        </div>
        <div id="info-panel">
            <div><strong>Orbital Period:</strong> <span id="period-display">365.25</span> days</div>
            <div><strong>Planet Radius:</strong> <span id="planet-radius-display">1.0</span> R‚äï</div>
            <div><strong>Star Radius:</strong> <span id="star-radius-display">1.0</span> R‚òâ</div>
            <div><strong>Star Temperature:</strong> <span id="star-temp-display">5778</span> K</div>
            <div><strong>Transit Duration:</strong> <span id="transit-duration-display">0.0</span> hours</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/104/three.min.js"></script>
    <script>
        console.log('Starting simple exoplanet animation...');
        
        // Animation parameters
        let animationParams = {
            orbitalPeriod: 365.25,
            planetRadius: 1.0,
            starRadius: 1.0,
            starTemperature: 5778,
            transitDuration: 0.0,
            isPlaying: false
        };

        // Three.js setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 1);
        document.getElementById('animation-container').appendChild(renderer.domElement);

        // Texture loader
        const textureLoader = new THREE.TextureLoader();
        
        // Load textures with fallbacks
        let sunTexture = null;
        let terrestrialTexture = null;
        
        // Load sun texture with absolute path
        const sunTexturePath = window.location.href.replace('corrected_transit_app.py', '') + 'sun.webp';
        console.log('Loading sun texture from:', sunTexturePath);
        textureLoader.load(sunTexturePath, 
            (texture) => {
                console.log('Sun texture loaded successfully');
                sunTexture = texture;
                updateStarTexture();
            },
            undefined,
            (error) => {
                console.log('Error loading sun.webp:', error);
                createFallbackSunTexture();
            }
        );
        
        // Load terrestrial texture with absolute path
        const terrestrialTexturePath = window.location.href.replace('corrected_transit_app.py', '') + 'terrestrial.jpg';
        console.log('Loading terrestrial texture from:', terrestrialTexturePath);
        textureLoader.load(terrestrialTexturePath,
            (texture) => {
                console.log('Terrestrial texture loaded successfully');
                terrestrialTexture = texture;
                updatePlanetTexture();
            },
            undefined,
            (error) => {
                console.log('Error loading terrestrial.jpg:', error);
                createFallbackPlanetTexture();
            }
        );

        // Create fallback textures
        function createFallbackSunTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(128, 128, 0, 128, 128, 128);
            gradient.addColorStop(0, '#ffaa00');
            gradient.addColorStop(1, '#ff6600');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 256, 256);
            sunTexture = new THREE.CanvasTexture(canvas);
            updateStarTexture();
        }

        function createFallbackPlanetTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(128, 128, 0, 128, 128, 128);
            gradient.addColorStop(0, '#0077ff');
            gradient.addColorStop(1, '#0044aa');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 256, 256);
            terrestrialTexture = new THREE.CanvasTexture(canvas);
            updatePlanetTexture();
        }

        // Create star (sun)
        const starGeometry = new THREE.SphereGeometry(2, 32, 32);
        const starMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xffaa00,
            emissive: 0xffaa00,
            emissiveIntensity: 0.3
        });
        const star = new THREE.Mesh(starGeometry, starMaterial);
        scene.add(star);

        // Create corona around the sun
        const coronaGeometry = new THREE.SphereGeometry(2.3, 32, 32);
        const coronaMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xffaa00,
            transparent: true,
            opacity: 0.3,
            side: THREE.BackSide
        });
        const corona = new THREE.Mesh(coronaGeometry, coronaMaterial);
        scene.add(corona);

        // Create outer glow layer
        const outerGlowGeometry = new THREE.SphereGeometry(2.6, 16, 16);
        const outerGlowMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xffaa00,
            transparent: true,
            opacity: 0.1,
            side: THREE.BackSide
        });
        const outerGlow = new THREE.Mesh(outerGlowGeometry, outerGlowMaterial);
        scene.add(outerGlow);

        // Create planet
        const planetGeometry = new THREE.SphereGeometry(0.3, 32, 32);
        const planetMaterial = new THREE.MeshBasicMaterial({ color: 0x0077ff });
        const planet = new THREE.Mesh(planetGeometry, planetMaterial);
        scene.add(planet);

        // Add some lighting for better texture visibility
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        
        const pointLight = new THREE.PointLight(0xffffff, 0.8, 100);
        pointLight.position.set(0, 0, 0);
        scene.add(pointLight);

        // Update textures when loaded
        function updateStarTexture() {
            if (sunTexture && star) {
                star.material.map = sunTexture;
                star.material.needsUpdate = true;
                console.log('Star texture updated');
            }
        }

        function updatePlanetTexture() {
            if (terrestrialTexture && planet) {
                planet.material.map = terrestrialTexture;
                planet.material.needsUpdate = true;
                console.log('Planet texture updated');
            }
        }

        // Create orbit ring
        const orbitGeometry = new THREE.RingGeometry(8, 8.2, 64);
        const orbitMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x444444, 
            transparent: true, 
            opacity: 0.5 
        });
        const orbitRing = new THREE.Mesh(orbitGeometry, orbitMaterial);
        orbitRing.rotation.x = -Math.PI / 2;
        scene.add(orbitRing);

        // Position camera
        camera.position.set(0, 5, 15);
        camera.lookAt(0, 0, 0);

        // Animation variables
        let startTime = Date.now();
        let isPlaying = false;
        let animationId = null;

        // Animation loop
        function animate() {
            if (!isPlaying) {
                requestAnimationFrame(animate);
                return;
            }

            const currentTime = Date.now();
            const elapsed = (currentTime - startTime) * 0.001;

            // Animate planet orbit
            const orbitRadius = 8;
            planet.position.x = Math.sin(elapsed) * orbitRadius;
            planet.position.z = Math.cos(elapsed) * orbitRadius;

            // Rotate star
            star.rotation.y += 0.01;

            // Rotate planet
            planet.rotation.y += 0.02;

            // Animate corona
            if (corona) {
                corona.rotation.y -= 0.005;
                // Pulsing corona effect
                const pulse = Math.sin(elapsed * 0.001) * 0.1 + 0.3;
                corona.material.opacity = pulse;
            }

            // Animate outer glow
            if (outerGlow) {
                outerGlow.rotation.y += 0.002;
                const glowPulse = Math.sin(elapsed * 0.0005) * 0.05 + 0.1;
                outerGlow.material.opacity = glowPulse;
            }

            // Check for transit (simple)
            const isInTransit = Math.abs(planet.position.x) < 2.5 && Math.abs(planet.position.z) < 2.5;
            if (isInTransit) {
                planet.material.color.setHex(0x00ff00); // Green when transiting
            } else {
                planet.material.color.setHex(0x0077ff); // Blue when not transiting
            }

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        // Control functions
        function togglePlayPause() {
            const playButton = document.getElementById('playButton');
            
            if (isPlaying) {
                isPlaying = false;
                playButton.textContent = '‚ñ∂Ô∏è Play';
                playButton.classList.remove('playing');
            } else {
                isPlaying = true;
                playButton.textContent = '‚è∏Ô∏è Pause';
                playButton.classList.add('playing');
                startTime = Date.now();
                animate();
            }
        }

        function resetAnimation() {
            isPlaying = false;
            startTime = Date.now();
            
            const playButton = document.getElementById('playButton');
            playButton.textContent = '‚ñ∂Ô∏è Play';
            playButton.classList.remove('playing');
            
            // Reset planet position
            planet.position.set(8, 0, 0);
            planet.material.color.setHex(0x0077ff);
            
            renderer.render(scene, camera);
        }

        // Mouse controls
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        renderer.domElement.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition.x = e.clientX;
            previousMousePosition.y = e.clientY;
        });

        renderer.domElement.addEventListener('mousemove', (e) => {
            if (!isDragging) return;

            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;

            camera.position.x -= deltaX * 0.01;
            camera.position.y += deltaY * 0.01;
            camera.lookAt(0, 0, 0);

            previousMousePosition.x = e.clientX;
            previousMousePosition.y = e.clientY;
        });

        renderer.domElement.addEventListener('mouseup', () => {
            isDragging = false;
        });

        // Zoom controls
        renderer.domElement.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomSpeed = 0.1;
            const direction = e.deltaY > 0 ? 1 : -1;
            camera.position.multiplyScalar(1 + direction * zoomSpeed);
        });

        // Update parameters function
        function updateParameters(params) {
            animationParams = { ...animationParams, ...params };
            updateDisplay();
            
            // Update star color based on temperature
            const temp = animationParams.starTemperature;
            let starColor;
            if (temp >= 10000) {
                starColor = 0x3fddff; // Blue
            } else if (temp >= 6000) {
                starColor = 0xffffff; // White
            } else if (temp >= 4000) {
                starColor = 0xffaa00; // Yellow
            } else {
                starColor = 0xff5030; // Red
            }
            
            // Only change color if texture failed to load
            if (!sunTexture) {
                star.material.color.setHex(starColor);
                star.material.emissive.setHex(starColor);
            } else {
                // Keep texture but adjust emissive color for temperature
                star.material.emissive.setHex(starColor);
                star.material.emissiveIntensity = 0.2;
            }

            // Update corona and glow colors
            if (corona) {
                corona.material.color.setHex(starColor);
            }
            if (outerGlow) {
                outerGlow.material.color.setHex(starColor);
            }
            
            // Update planet size
            const planetSize = Math.max(0.1, Math.min(1.0, animationParams.planetRadius * 0.2));
            planet.geometry = new THREE.SphereGeometry(planetSize, 32, 32);
            
            // Update star size
            const starSize = Math.max(1.0, Math.min(5.0, animationParams.starRadius * 2));
            star.geometry = new THREE.SphereGeometry(starSize, 32, 32);
            
            // Update corona size
            if (corona) {
                corona.geometry = new THREE.SphereGeometry(starSize * 1.15, 32, 32);
            }
            if (outerGlow) {
                outerGlow.geometry = new THREE.SphereGeometry(starSize * 1.3, 16, 16);
            }
            
            // Update orbit radius
            const orbitRadius = Math.max(5, Math.min(20, Math.sqrt(animationParams.orbitalPeriod) * 0.5));
            orbitRing.geometry = new THREE.RingGeometry(orbitRadius, orbitRadius + 0.2, 64);
        }

        function updateDisplay() {
            document.getElementById('period-display').textContent = animationParams.orbitalPeriod.toFixed(2);
            document.getElementById('planet-radius-display').textContent = animationParams.planetRadius.toFixed(2);
            document.getElementById('star-radius-display').textContent = animationParams.starRadius.toFixed(2);
            document.getElementById('star-temp-display').textContent = animationParams.starTemperature.toFixed(0);
            document.getElementById('transit-duration-display').textContent = animationParams.transitDuration.toFixed(2);
        }

        // Initialize
        console.log('Simple animation initialized!');
        updateDisplay();
        animate();

        // Make functions available globally
        window.updateAnimationParameters = updateParameters;
        window.togglePlayPause = togglePlayPause;
        window.resetAnimation = resetAnimation;
    </script>
</body>
</html>
