<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exoplanet Transit Animation</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
        #animation-container {
            width: 100%;
            height: 100vh;
            position: relative;
        }
        #controls {
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 100;
            background: linear-gradient(135deg, rgba(0,0,0,0.8), rgba(20,20,20,0.9));
            padding: 15px;
            border-radius: 12px;
            color: white;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
        }
        #info-panel {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 100;
            background: linear-gradient(135deg, rgba(0,0,0,0.8), rgba(20,20,20,0.9));
            padding: 15px;
            border-radius: 12px;
            color: white;
            font-size: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
            min-width: 200px;
        }
        .control-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            padding: 10px 16px;
            margin: 4px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            min-width: 80px;
        }
        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            background: linear-gradient(135deg, #5a6fd8 0%, #6a4190 100%);
        }
        .control-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }
        .control-button:disabled {
            background: linear-gradient(135deg, #666 0%, #555 100%);
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .control-button.playing {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
        }
        .control-button.playing:hover {
            background: linear-gradient(135deg, #ff5252 0%, #e74c3c 100%);
        }
        .control-button.reset {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
        }
        .control-button.reset:hover {
            background: linear-gradient(135deg, #e67e22 0%, #d35400 100%);
        }
    </style>
</head>
<body>
    <div id="animation-container">
        <div id="controls">
            <button id="playButton" class="control-button" onclick="togglePlayPause()">‚ñ∂Ô∏è Play</button>
            <button id="resetButton" class="control-button reset" onclick="resetAnimation()">üîÑ Reset</button>
        </div>
        <div id="info-panel">
            <div><strong>Orbital Period:</strong> <span id="period-display">365.25</span> days</div>
            <div><strong>Planet Radius:</strong> <span id="planet-radius-display">1.0</span> R‚äï</div>
            <div><strong>Star Radius:</strong> <span id="star-radius-display">1.0</span> R‚òâ</div>
            <div><strong>Star Temperature:</strong> <span id="star-temp-display">5778</span> K</div>
            <div><strong>Transit Duration:</strong> <span id="transit-duration-display">0.0</span> hours</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/104/three.min.js"></script>
    <script>
        // Animation parameters - will be set by Streamlit
        let animationParams = {
            orbitalPeriod: 365.25,
            planetRadius: 1.0,
            starRadius: 1.0,
            starTemperature: 5778,
            transitDuration: 0.0,
            isPlaying: false
        };

        // Three.js setup
        const scene = new THREE.Scene();
        const width = window.innerWidth;
        const height = window.innerHeight;
        
        const camera = new THREE.PerspectiveCamera(60, width / height, 1, 1000000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(width, height);
        renderer.setClearColor(0x000000, 1);
        
        document.getElementById('animation-container').appendChild(renderer.domElement);

        // Texture loader
        const textureLoader = new THREE.TextureLoader();
        const sunTexture = textureLoader.load('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjU2IiBoZWlnaHQ9IjI1NiIgdmlld0JveD0iMCAwIDI1NiAyNTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIyNTYiIGhlaWdodD0iMjU2IiBmaWxsPSIjRkZEMTAwIi8+Cjwvc3ZnPgo=');
        const terrestrialTexture = textureLoader.load('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjU2IiBoZWlnaHQ9IjI1NiIgdmlld0JveD0iMCAwIDI1NiAyNTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIyNTYiIGhlaWdodD0iMjU2IiBmaWxsPSIjMDA3N0ZGIi8+Cjwvc3ZnPgo=');

        // Calculate derived parameters
        function calculateDerivedParams() {
            // Convert Earth radii to Solar radii: 1 R_earth = 0.009167 R_sun
            const planetRadiusSolar = animationParams.planetRadius * 0.009167;
            const planetStarRatio = planetRadiusSolar / animationParams.starRadius;
            
            // Calculate orbital radius (scaled for visualization)
            // Use Kepler's third law: P¬≤ ‚àù a¬≥, so a ‚àù P^(2/3)
            const baseOrbitalRadius = 25;
            const orbitalRadius = Math.max(baseOrbitalRadius, baseOrbitalRadius * Math.pow(animationParams.orbitalPeriod / 365.25, 2/3));
            
            // Calculate planet size (scaled for visualization, but keep it visible)
            const planetSize = Math.max(0.3, Math.min(3.0, planetStarRatio * 25));
            
            // Calculate star size (scaled for visualization)
            const starSize = Math.max(3, Math.min(20, animationParams.starRadius * 8));
            
            // Calculate orbit speed (inversely proportional to orbital period)
            // Make it more dramatic for visualization
            const baseSpeed = 0.001;
            const orbitSpeed = baseSpeed * Math.sqrt(365.25 / animationParams.orbitalPeriod);
            
            return {
                planetSize,
                starSize,
                orbitalRadius,
                orbitSpeed,
                planetStarRatio
            };
        }

        // Create objects
        let planet, star, corona, orbitRing;
        let derivedParams = calculateDerivedParams();

        function createObjects() {
            // Remove existing objects
            if (planet) scene.remove(planet);
            if (star) scene.remove(star);
            if (corona) scene.remove(corona);
            if (orbitRing) scene.remove(orbitRing);

            // Create planet
            const planetGeometry = new THREE.SphereGeometry(derivedParams.planetSize, 32, 32);
            const planetMaterial = new THREE.MeshStandardMaterial({ map: terrestrialTexture });
            planet = new THREE.Mesh(planetGeometry, planetMaterial);
            planet.name = "planet";
            scene.add(planet);

            // Create star
            const starGeometry = new THREE.SphereGeometry(derivedParams.starSize, 32, 32);
            const starMaterial = new THREE.MeshStandardMaterial({ map: sunTexture });
            star = new THREE.Mesh(starGeometry, starMaterial);
            star.name = "star";
            scene.add(star);

            // Create corona
            const coronaGeometry = new THREE.SphereGeometry(derivedParams.starSize * 1.1, 32, 32);
            const coronaMaterial = new THREE.MeshStandardMaterial({ 
                map: sunTexture, 
                transparent: true, 
                opacity: 0.3 
            });
            corona = new THREE.Mesh(coronaGeometry, coronaMaterial);
            corona.name = "corona";
            scene.add(corona);

            // Create orbit ring
            const orbitGeometry = new THREE.RingGeometry(
                derivedParams.orbitalRadius - 0.2, 
                derivedParams.orbitalRadius + 0.2, 
                64
            );
            const orbitMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x444444, 
                transparent: true, 
                opacity: 0.5 
            });
            orbitRing = new THREE.Mesh(orbitGeometry, orbitMaterial);
            orbitRing.rotation.x = -Math.PI / 2;
            orbitRing.name = "orbit";
            scene.add(orbitRing);
        }

        // Lighting setup
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        const sunLight = new THREE.PointLight(0xffffff, 1, 1000);
        const sunSpotlight1 = new THREE.SpotLight(0xffaa00, 2, 0, Math.PI/4, 0.1, 0);
        const sunSpotlight2 = new THREE.SpotLight(0xff6600, 1, 0, Math.PI/4, 0.1, 0);

        scene.add(ambientLight);
        scene.add(sunLight);
        scene.add(sunSpotlight1);
        scene.add(sunSpotlight2);

        // Camera setup
        camera.position.set(0, derivedParams.orbitalRadius * 0.5, derivedParams.orbitalRadius * 0.8);
        camera.lookAt(0, 0, 0);

        // Animation variables
        let startTime = Date.now();
        let pauseTime = 0;
        let isPlaying = false;
        let animationId = null;

        // Star color based on temperature
        function updateStarColor() {
            const temp = animationParams.starTemperature;
            let color1, color2, intensity1, intensity2;

            if (temp >= 30000) {
                color1 = 0x3fddff; intensity1 = 10;
                color2 = 0x3feaff; intensity2 = 4;
            } else if (temp >= 10000) {
                color1 = 0x3fddff; intensity1 = 20;
                color2 = 0x3feaff; intensity2 = 8;
            } else if (temp >= 7500) {
                color1 = 0x3fddff; intensity1 = 55;
                color2 = 0x3feaff; intensity2 = 10;
            } else if (temp >= 6000) {
                color1 = 0xdfa010; intensity1 = 55;
                color2 = 0xdea010; intensity2 = 30;
            } else if (temp >= 5200) {
                color1 = 0xffa010; intensity1 = 35;
                color2 = 0xffff10; intensity2 = 1;
            } else if (temp >= 3700) {
                color1 = 0xff5030; intensity1 = 30;
                color2 = 0xffffff; intensity2 = 1;
            } else {
                color1 = 0xff1010; intensity1 = 30;
                color2 = 0xff1010; intensity2 = 1;
            }

            sunSpotlight1.color.setHex(color1);
            sunSpotlight1.intensity = intensity1;
            sunSpotlight2.color.setHex(color2);
            sunSpotlight2.intensity = intensity2;
        }

        // Animation loop
        function animate() {
            const currentTime = Date.now();
            const elapsed = (currentTime - startTime - pauseTime) * derivedParams.orbitSpeed;

            if (planet) {
                // Planet orbit
                planet.position.x = Math.sin(elapsed) * derivedParams.orbitalRadius;
                planet.position.z = Math.cos(elapsed) * derivedParams.orbitalRadius;
                planet.rotation.y += 0.01;

                // Check for transit
                const planetX = planet.position.x;
                const starRadius = derivedParams.starSize;
                const planetRadius = derivedParams.planetSize;
                
                // Simple transit detection (planet crossing in front of star)
                const isInTransit = Math.abs(planetX) < (starRadius + planetRadius) && 
                                  planet.position.z > -starRadius && 
                                  planet.position.z < starRadius;
                
                if (isInTransit) {
                    planet.material.emissive.setHex(0x004400);
                } else {
                    planet.material.emissive.setHex(0x000000);
                }
            }

            if (star) {
                star.rotation.y -= 0.005;
            }

            if (corona) {
                corona.rotation.y -= 0.002;
            }

            // Update spotlight positions
            sunSpotlight1.position.copy(camera.position);
            sunSpotlight2.position.copy(camera.position);

            renderer.render(scene, camera);
            if (isPlaying) {
                animationId = requestAnimationFrame(animate);
            }
        }

        // Control functions
        function togglePlayPause() {
            const playButton = document.getElementById('playButton');
            
            if (isPlaying) {
                // Pause animation
                isPlaying = false;
                pauseTime += Date.now() - (startTime + pauseTime);
                playButton.textContent = '‚ñ∂Ô∏è Play';
                playButton.classList.remove('playing');
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
            } else {
                // Play animation
                isPlaying = true;
                playButton.textContent = '‚è∏Ô∏è Pause';
                playButton.classList.add('playing');
                animate();
            }
        }

        function resetAnimation() {
            isPlaying = false;
            pauseTime = 0;
            startTime = Date.now();
            
            const playButton = document.getElementById('playButton');
            playButton.textContent = '‚ñ∂Ô∏è Play';
            playButton.classList.remove('playing');
            
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            
            if (planet) {
                planet.position.set(derivedParams.orbitalRadius, 0, 0);
            }
            renderer.render(scene, camera);
        }

        // Update parameters function (called by Streamlit)
        function updateParameters(params) {
            animationParams = { ...animationParams, ...params };
            derivedParams = calculateDerivedParams();
            createObjects();
            updateStarColor();
            updateDisplay();
            
            // Reset animation state
            isPlaying = false;
            pauseTime = 0;
            startTime = Date.now();
            
            const playButton = document.getElementById('playButton');
            if (playButton) {
                playButton.textContent = '‚ñ∂Ô∏è Play';
                playButton.classList.remove('playing');
            }
            
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            
            // Reset camera position
            camera.position.set(0, derivedParams.orbitalRadius * 0.5, derivedParams.orbitalRadius * 0.8);
            camera.lookAt(0, 0, 0);
            
            // Render initial frame
            renderer.render(scene, camera);
        }

        function updateDisplay() {
            document.getElementById('period-display').textContent = animationParams.orbitalPeriod.toFixed(2);
            document.getElementById('planet-radius-display').textContent = animationParams.planetRadius.toFixed(2);
            document.getElementById('star-radius-display').textContent = animationParams.starRadius.toFixed(2);
            document.getElementById('star-temp-display').textContent = animationParams.starTemperature.toFixed(0);
            document.getElementById('transit-duration-display').textContent = animationParams.transitDuration.toFixed(2);
        }

        // Mouse controls
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        renderer.domElement.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition.x = e.clientX;
            previousMousePosition.y = e.clientY;
        });

        renderer.domElement.addEventListener('mousemove', (e) => {
            if (!isDragging) return;

            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;

            camera.position.x -= deltaX * 0.01;
            camera.position.y += deltaY * 0.01;
            camera.lookAt(0, 0, 0);

            previousMousePosition.x = e.clientX;
            previousMousePosition.y = e.clientY;
        });

        renderer.domElement.addEventListener('mouseup', () => {
            isDragging = false;
        });

        // Zoom controls
        renderer.domElement.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomSpeed = 0.1;
            const direction = e.deltaY > 0 ? 1 : -1;
            camera.position.multiplyScalar(1 + direction * zoomSpeed);
        });

        // Initialize
        createObjects();
        updateStarColor();
        updateDisplay();
        animate();

        // Make functions available globally for Streamlit
        window.updateAnimationParameters = updateParameters;
        window.togglePlayPause = togglePlayPause;
        window.resetAnimation = resetAnimation;
    </script>
</body>
</html>
